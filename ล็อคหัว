local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local camera = Workspace.CurrentCamera

local Config = {
    Enabled = true,
    FOV = 50,
    MaxDistance = 200,
    Smoothness = 100,
    AimBoneName = "Head",
    ShowFOVCircle = true,
    OnlyWhenHoldRight = false,
}

local fovCircle
if Config.ShowFOVCircle then
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "AimDevGUI"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = player:WaitForChild("PlayerGui")

    fovCircle = Instance.new("Frame")
    fovCircle.Name = "FOVCircle"
    fovCircle.Parent = screenGui
    fovCircle.BackgroundTransparency = 1
    fovCircle.AnchorPoint = Vector2.new(0.5, 0.5)
    fovCircle.Position = UDim2.new(0.5, 0, 0.5, 0)
    fovCircle.Size = UDim2.new(0, 300, 0, 300)
    fovCircle.BackgroundColor3 = Color3.fromRGB(0, 0, 0)

    local corner = Instance.new("UICorner", fovCircle)
    corner.CornerRadius = UDim.new(0.5, 0)

    local stroke = Instance.new("UIStroke", fovCircle)
    stroke.Thickness = 2
    stroke.Transparency = 0.4
    stroke.LineJoinMode = Enum.LineJoinMode.Round
end

local function worldToScreen(pos)
    local p, onScreen = camera:WorldToViewportPoint(pos)
    return Vector2.new(p.X, p.Y), onScreen, p.Z
end

local function getTargetHeadPos(target)
    if not target or not target.PrimaryPart then
        local head = target:FindFirstChild("Head") or target:FindFirstChild(Config.AimBoneName)
        if head then return head.Position end
        return nil
    end
    local head = target:FindFirstChild("Head")
    if head then return head.Position end
    return target.PrimaryPart.Position
end

local function getPotentialTargets()
    local list = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= player and p.Character and p.Character:FindFirstChild("Humanoid") and p.Character.Humanoid.Health > 0 then
            table.insert(list, p.Character)
        end
    end
    return list
end

local function angleBetweenVectors(a, b)
    local na = a.Unit
    local nb = b.Unit
    local dot = na:Dot(nb)
    dot = math.clamp(dot, -1, 1)
    return math.deg(math.acos(dot))
end

local function chooseBestTarget()
    local camPos = camera.CFrame.Position
    local camLook = camera.CFrame.LookVector
    local best = nil
    local bestScore = 1e9
    for _, char in ipairs(getPotentialTargets()) do
        local headPos = getTargetHeadPos(char)
        if headPos then
            local toTarget = headPos - camPos
            local dist = toTarget.Magnitude
            if dist <= Config.MaxDistance then
                local ang = angleBetweenVectors(camLook, toTarget)
                if ang <= (Config.FOV/2) then
                    local visible = true
                    local ignoreList = {player.Character}
                    local rayParams = RaycastParams.new()
                    rayParams.FilterDescendantsInstances = ignoreList
                    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
                    rayParams.IgnoreWater = true
                    local rayResult = workspace:Raycast(camPos, toTarget, rayParams)
                    if rayResult and not rayResult.Instance:IsDescendantOf(char) then
                        visible = false
                    end
                    if visible then
                        local score = ang * 1.0 + (dist/10)
                        if score < bestScore then
                            bestScore = score
                            best = {character = char, headPos = headPos}
                        end
                    end
                end
            end
        end
    end
    return best
end

local function smoothLookTowards(dt, desiredPos)
    local camPos = camera.CFrame.Position
    local currentLook = camera.CFrame.LookVector
    local desiredLook = (desiredPos - camPos).Unit
    local t = 1 - math.exp(-Config.Smoothness * dt)
    local newLook = currentLook:Lerp(desiredLook, t)
    camera.CFrame = CFrame.new(camPos, camPos + newLook)
end

local holdingRight = false
UserInputService.InputBegan:Connect(function(inp, gameProcessed)
    if inp.UserInputType == Enum.UserInputType.MouseButton2 then holdingRight = true end
end)
UserInputService.InputEnded:Connect(function(inp)
    if inp.UserInputType == Enum.UserInputType.MouseButton2 then holdingRight = false end
end)

if fovCircle then
    local baseSize = 300
    fovCircle.Size = UDim2.new(0, baseSize, 0, baseSize)
end

local last = tick()
RunService:BindToRenderStep("AimAssistDev", Enum.RenderPriority.Camera.Value + 1, function()
    local now = tick()
    local dt = now - last
    last = now

    if not Config.Enabled then return end
    if Config.OnlyWhenHoldRight and not holdingRight then return end

    local best = chooseBestTarget()
    if best then
        smoothLookTowards(dt, best.headPos)
    end
end)
